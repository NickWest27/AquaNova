<!-- UI of the bridge -->
 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Right-Side Nav Display</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; }
    body {
      background: #111; /* page edge */
      display: grid;
      place-items: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      width: min(96vw, 700px);
      height: min(96vh, 1000px);
      aspect-ratio: 3/4; /* tall, like an avionics screen */
      background: #000; /* instrument bezel */
      border-radius: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.6), inset 0 0 0 2px #202020;
      padding: 16px;
      display: grid;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 12px;
      background: #000; /* display background */
    }
    .legend {
      position: absolute; left: 50%; transform: translateX(-50%);
      bottom: 8px; color: #9aa0a6; font-size: 12px; letter-spacing: .02em;
      user-select: none; pointer-events: none;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="nd"></canvas>
  </div>
  <div class="legend">Right-Side Nav Display • Rings, Compass Rose, Ownship, Track, Waypoint</div>

  <script>
    // --- Configurable parameters -------------------------------------------
    const CONFIG = {
      ringCount: 4,                 // number of visible concentric range rings
      ringLabelEvery: 1,            // label every N rings (set 0 to disable)
      showCardinals: true,          // show N / E / S / W on the compass rose
      minorTickEvery: 10,           // minor tick degrees
      majorTickEvery: 30,           // major tick degrees with numbers
      shipYFraction: 2/3,           // ship (and ring center) vertical placement
      trackColor: '#00ff7f',        // green nav track (no alpha for crisp lines)
      strokeColor: '#ffffff',       // primary stroke color
      textColor:   '#ffffff',       // label color
      fontPx: 12,                   // base font size (scaled with DPR)
      // Example flight plan: single waypoint ahead at 030° / 70% of max radius
      waypoint: {
        name: 'LEDDR',
        bearingDeg: 30,             // 0 = up (north/top). Positive clockwise.
        radiusFrac: 0.70            // 0..1 of max drawable radius
      }
    };

    // --- Canvas & HiDPI setup ----------------------------------------------
    const canvas = document.getElementById('nd');
    const ctx = canvas.getContext('2d');

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const { clientWidth: w, clientHeight: h } = canvas;
      canvas.width = Math.round(w * dpr);
      canvas.height = Math.round(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // UI units = CSS pixels
      draw();
    }

    window.addEventListener('resize', resize, { passive: true });
    window.addEventListener('orientationchange', resize, { passive: true });

    // --- Drawing helpers ----------------------------------------------------
    function draw() {
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      // Clear background
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      // Center for range rings / compass: horizontally centered, 2/3 down
      const cx = W / 2;
      const cy = H * CONFIG.shipYFraction;

      // Max radius limited by distance to nearest edge
      const maxR = Math.min(cx, W - cx, cy, H - cy) - 8; // margin

      drawRangeRings(cx, cy, maxR);
      drawCompassRose(cx, cy, maxR);
      drawOwnShip(cx, cy, Math.max(8, maxR * 0.035));
      drawTrackAndWaypoint(cx, cy, maxR);
    }

    function strokeCircle(x, y, r) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawRangeRings(cx, cy, maxR) {
      const { ringCount, strokeColor } = CONFIG;
      ctx.save();
      ctx.lineWidth = 1; // in CSS pixels; HiDPI handled by setTransform
      ctx.strokeStyle = strokeColor;

      for (let i = 1; i <= ringCount; i++) {
        const r = (i / ringCount) * maxR;
        // Use a dashed style for the mid ring for subtle variety
        if (i === Math.ceil(ringCount / 2)) {
          ctx.setLineDash([4, 4]);
        } else {
          ctx.setLineDash([]);
        }
        strokeCircle(cx, cy, r);
      }

      ctx.restore();
    }

    function drawCompassRose(cx, cy, maxR) {
      const {
        minorTickEvery, majorTickEvery, showCardinals, textColor, strokeColor, fontPx
      } = CONFIG;

      const outerR = maxR; // ticks on the outermost ring
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = strokeColor;
      ctx.fillStyle = textColor;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${fontPx}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;

      const rad = (deg) => (deg - 0) * Math.PI / 180; // 0° at up; clockwise to the right

      for (let d = 0; d < 360; d += minorTickEvery) {
        const isMajor = d % majorTickEvery === 0;
        const tickLen = isMajor ? 10 : 5;
        const a = rad(d);
        const sx = cx + Math.sin(a) * (outerR - tickLen);
        const sy = cy - Math.cos(a) * (outerR - tickLen);
        const ex = cx + Math.sin(a) * outerR;
        const ey = cy - Math.cos(a) * outerR;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();

        if (isMajor) {
          // Label every major tick with degrees, and cardinals when applicable
          const labelR = outerR + 16;
          const lx = cx + Math.sin(a) * labelR;
          const ly = cy - Math.cos(a) * labelR;

          let label = String(d);
          if (showCardinals) {
            if (d === 0) label = 'N';
            else if (d === 90) label = 'E';
            else if (d === 180) label = 'S';
            else if (d === 270) label = 'W';
          }

          ctx.fillText(label, lx, ly);
        }
      }

      ctx.restore();
    }

    function drawOwnShip(cx, cy, size) {
      // White filled triangle pointing up
      const s = size;
      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(cx, cy - s);        // tip
      ctx.lineTo(cx - s * 0.75, cy + s * 0.9);
      ctx.lineTo(cx + s * 0.75, cy + s * 0.9);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawTrackAndWaypoint(cx, cy, maxR) {
      const { waypoint, trackColor, textColor, strokeColor, fontPx } = CONFIG;
      if (!waypoint) return;

      // Convert polar to canvas coordinates.
      // By convention here: 0° = up (north), increasing clockwise.
      const a = waypoint.bearingDeg * Math.PI / 180;
      const r = Math.max(0, Math.min(1, waypoint.radiusFrac)) * maxR;
      const wx = cx + Math.sin(a) * r;
      const wy = cy - Math.cos(a) * r;

      // Track line from ownship to waypoint
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = trackColor;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(wx, wy);
      ctx.stroke();

      // Waypoint diamond (white)
      const d = Math.max(6, maxR * 0.025);
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(wx, wy - d);
      ctx.lineTo(wx + d, wy);
      ctx.lineTo(wx, wy + d);
      ctx.lineTo(wx - d, wy);
      ctx.closePath();
      ctx.stroke();

      // Label next to diamond
      ctx.fillStyle = textColor;
      ctx.font = `${fontPx}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      const label = waypoint.name || 'WPT';
      ctx.fillText(label, wx + d + 6, wy);

      ctx.restore();
    }

    // --- Kick things off ----------------------------------------------------
    // Initial draw after layout
    requestAnimationFrame(resize);

    // Optional: keyboard tweaks for quick demo/testing
    // ArrowLeft/Right: change bearing; ArrowUp/Down: change radius; +/- rename
    window.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowLeft':
          CONFIG.waypoint.bearingDeg = (CONFIG.waypoint.bearingDeg - 5 + 360) % 360; draw(); break;
        case 'ArrowRight':
          CONFIG.waypoint.bearingDeg = (CONFIG.waypoint.bearingDeg + 5) % 360; draw(); break;
        case 'ArrowUp':
          CONFIG.waypoint.radiusFrac = Math.min(1, CONFIG.waypoint.radiusFrac + 0.02); draw(); break;
        case 'ArrowDown':
          CONFIG.waypoint.radiusFrac = Math.max(0.05, CONFIG.waypoint.radiusFrac - 0.02); draw(); break;
      }
    });
  </script>
</body>
</html>
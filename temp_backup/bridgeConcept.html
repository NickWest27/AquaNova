<!-- UI of the bridge -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AquaNova Submarine Navigation Display</title>
    <style>
        :root { color-scheme: dark; }
        html, body { height: 100%; margin: 0; }
        body {
            background: #111;
            display: grid;
            place-items: center;
            font-family: 'Courier New', monospace;
        }
        .wrap {
            width: min(96vw, 600px);
            height: min(96vh, 600px);
            aspect-ratio: 1;
            background: #000;
            border-radius: 18px;
            box-shadow: 0 10px 30px rgba(0,0,0,.6), inset 0 0 0 2px #333;
            padding: 16px;
            display: grid;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 12px;
            background: #000;
        }
        .legend {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 8px;
            color: #9aa0a6;
            font-size: 12px;
            letter-spacing: .02em;
            user-select: none;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <canvas id="nd"></canvas>
    </div>
    <div class="legend">AquaNova Submarine Navigation Display</div>

    <script>
        const CONFIG = {
            ringCount: 4,
            shipYFraction: 2/3,
            strokeColor: '#ffffff',
            textColor: '#ffffff',
            fontPx: 12,
        };

        const canvas = document.getElementById('nd');
        const ctx = canvas.getContext('2d');

        function resize() {
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const { clientWidth: w, clientHeight: h } = canvas;
            canvas.width = Math.round(w * dpr);
            canvas.height = Math.round(h * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            draw();
        }

        window.addEventListener('resize', resize, { passive: true });

        function draw() {
            const W = canvas.clientWidth;
            const H = canvas.clientHeight;

            // Clear background
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);

            // Ownship position: centered horizontally, 2/3 down vertically
            const cx = W / 2;
            const cy = H * CONFIG.shipYFraction;

            // Base radius for rings - use a consistent size regardless of clipping
            const baseRadius = Math.min(W, H) * 0.15;

            drawRangeRings(cx, cy, baseRadius);
            drawCompassRose(cx, cy, baseRadius * 4);
            drawOwnShip(cx, cy);
        }

        function drawRangeRings(cx, cy, baseRadius) {
            ctx.save();
            ctx.lineWidth = 1;
            ctx.strokeStyle = CONFIG.strokeColor;

            // Draw 3 dashed rings and 1 solid ring
            for (let i = 1; i <= CONFIG.ringCount; i++) {
                const r = i * baseRadius;
                
                if (i < CONFIG.ringCount) {
                    // Dashed rings
                    ctx.setLineDash([4, 4]);
                } else {
                    // Solid outer ring (compass rose)
                    ctx.setLineDash([]);
                    ctx.lineWidth = 2;
                }
                
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawCompassRose(cx, cy, outerRadius) {
            ctx.save();
            ctx.strokeStyle = CONFIG.strokeColor;
            ctx.fillStyle = CONFIG.textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `${CONFIG.fontPx}px monospace`;

            // Draw heading ticks and numbers
            for (let deg = 0; deg < 360; deg += 5) {
                const isMajor = deg % 10 === 0;
                const tickLength = isMajor ? 15 : 8;
                
                const rad = (deg * Math.PI) / 180;
                const x1 = cx + Math.sin(rad) * (outerRadius - tickLength);
                const y1 = cy - Math.cos(rad) * (outerRadius - tickLength);
                const x2 = cx + Math.sin(rad) * outerRadius;
                const y2 = cy - Math.cos(rad) * outerRadius;

                ctx.lineWidth = isMajor ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // Add numbers every 10 degrees (two digit format)
                if (deg % 10 === 0) {
                    const textRadius = outerRadius + 20;
                    const textX = cx + Math.sin(rad) * textRadius;
                    const textY = cy - Math.cos(rad) * textRadius;
                    
                    const label = (deg / 10).toString().padStart(2, '0');
                    
                    ctx.fillText(label, textX, textY);
                }
            }

            ctx.restore();
        }

        function drawOwnShip(cx, cy) {
            const size = 12;
            ctx.save();
            ctx.fillStyle = CONFIG.strokeColor;
            ctx.beginPath();
            ctx.moveTo(cx, cy - size);
            ctx.lineTo(cx - size * 0.6, cy + size * 0.7);
            ctx.lineTo(cx + size * 0.6, cy + size * 0.7);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Initialize
        requestAnimationFrame(resize);
    </script>
</body>
</html>